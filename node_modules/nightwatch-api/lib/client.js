"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteRunner = deleteRunner;
exports.startWebDriver = startWebDriver;
exports.stopWebDriver = stopWebDriver;
exports.createSession = createSession;
exports.closeSession = closeSession;
exports.runQueue = runQueue;
exports.getNewScreenshots = getNewScreenshots;

var _nightwatch = require("nightwatch");

var _fs = _interopRequireDefault(require("fs"));

var _logger = require("./logger");

var _screenshots = require("./screenshots");

var _reporter = _interopRequireDefault(require("./reporter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let runner;
let runnerOptions;
let client;
let screenshots = [];

function deleteRunner() {
  runner = null;
  runnerOptions = null;
  client = null;
}

function getDefaultEnvironment() {
  return 'default';
}

function getDefaultConfigFile() {
  const jsonConfigFile = './nightwatch.json';
  const jsConfigFie = './nightwatch.conf.js';

  if (_fs.default.existsSync(jsonConfigFile)) {
    return jsonConfigFile;
  }

  if (_fs.default.existsSync(jsConfigFie)) {
    return jsConfigFie;
  }

  throw new Error(['No configuration file was found for Nightwatch in the current process folder.', '(nightwatch.json or nightwatch.conf.js).', 'For custom location please provide "configFile" option for "startWebDriver" or', '"createSession" functions.'].join(' '));
}

function createRunner(options) {
  if (!runner) {
    runnerOptions = {
      env: options && options.env || getDefaultEnvironment(),
      configFile: options && options.configFile || getDefaultConfigFile(),
      silent: options && options.silent || false
    };
    runner = (0, _nightwatch.CliRunner)({
      env: runnerOptions.env,
      config: runnerOptions.configFile
    });

    runner.isWebDriverManaged = function () {
      if (this.baseSettings.selenium) {
        this.baseSettings.selenium.start_process = true;
      }

      return true;
    };

    runner.setup();
  }

  return runner;
}

async function startWebDriver(options) {
  deleteRunner();
  const runner = createRunner(options);
  const {
    port
  } = runner.test_settings.webdriver;
  await runner.startWebDriver();
  (0, _logger.log)(`WebDriver started on port ${port} for ${runner.testEnv} environment`);
}

async function stopWebDriver() {
  if (!runner) {
    return;
  }

  const {
    port
  } = runner.test_settings.webdriver;
  await runner.stopWebDriver();
  (0, _logger.log)(`WebDriver stopped on port ${port} for ${runner.testEnv} environment`);
}

async function createSession(options) {
  if (options) {
    deleteRunner();
  }

  const runner = createRunner(options);
  const settings = runner.test_settings;
  client = runnerOptions && runnerOptions.silent ? (0, _nightwatch.client)(settings) : (0, _nightwatch.client)(settings, new _reporter.default());
  (0, _logger.log)(`Creating session for ${runner.testEnv} environment on port ${settings.webdriver.port}`);
  await client.startSession();
  (0, _logger.log)(`Session created for ${runner.testEnv} environment`);
  return client.api;
}

function resetQueue() {
  if (client && client.queue) {
    client.queue.reset().removeAllListeners().empty();
  }
}

async function closeSession() {
  await new Promise(resolve => {
    if (!client) {
      return;
    }

    client.transportActions.sessionAction('DELETE', client.sessionId, resolve);
  });
  /* istanbul ignore next */

  if (runner) {
    (0, _logger.log)(`Session closed for ${runner.testEnv} environment`);
  }
}

async function handleQueueResult(err, resolve, reject) {
  if (!err) {
    resolve();
    return;
  }

  if (client && client.api.screenshotsPath) {
    (0, _logger.log)('Creating screenshot because of failure');
    const fileName = await (0, _screenshots.createFailureScreenshot)(client);
    screenshots.push(fileName);
  }

  err.stack = [err.message, err.stack].join('\n');
  reject(err);
}

async function runQueue() {
  try {
    await new Promise((resolve, reject) => {
      if (!client || !client.queue) {
        throw new Error(`Nightwatch client is not ready.
            Looks like function "createSession" did not succeed or was not called yet.`);
      }

      client.queue.once('queue:finished', async err => await handleQueueResult(err, resolve, reject));
      client.queue.run();
    });
  } catch (err) {
    throw err;
  } finally {
    resetQueue();
  }
}

function getNewScreenshots() {
  const result = screenshots;
  screenshots = [];
  return result;
}